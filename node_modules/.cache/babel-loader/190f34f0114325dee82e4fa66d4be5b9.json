{"ast":null,"code":"var _jsxFileName = \"C:\\\\Code\\\\minireact\\\\src\\\\index.js\";\n\n// const element = (\n//   <div id='foo'>\n//     <a>bar</a>\n//     <b />\n//   </div>\n// );\n// ↓ 相当于使用 React.createElement ↓\n// const element = React.createElement(\n//   'div',\n//   { id: 'foo' },\n//   React.createElement('a', null, 'bar'),\n//   React.createElement('b'),\n// );\n// ↓ 将 React.createElement 改写为原生 JS 的 createElement ↓\nfunction createElement(type, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n\n  // 使用 rest parameter 将 children 转化为数组 -> 这样方便通过 map 方法遍历 children 了\n  return {\n    type,\n    props: { ...props,\n      children: children.map(child => {\n        return typeof child === 'object' ? child : createTextElement(child); // 如果 child 是字符串,则创建文本节点;如果 child 是对象,则直接返回\n      })\n    }\n  };\n} // 创建处理文字节点的函数 createTextElement()\n\n\nfunction createTextElement(text) {\n  return {\n    type: 'TEXT_ELEMENT',\n    // 为文字节点特设的类型\n    props: {\n      nodeValue: text,\n      children: [] // 注意:React 不会包裹原始值,而是直接将原始值作为节点的属性;也不会在没有子节点时创建空的数组...\n\n    }\n  };\n}\n\nfunction render(element, container) {\n  const dom = element.type == 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(element.type); // 进一步考虑:要根据元素类型进行不同的处理,即文本节点和元素节点两种情况。\n\n  const isProperty = key => key !== 'children';\n\n  Object.keys(element.props).filter(isProperty).forEach(name => dom[name] = element.props[name]); // 将元素的属性分配每个节点...\n\n  element.props.children.forEach(child => {\n    render(child, dom);\n  }); // element 的子节点也要通过遍历 render 函数来创建\n\n  container.appendChild(dom);\n}\n\nconst myReact = {\n  createElement,\n  render\n}; // const element = myReact.createElement(\n//   'div',\n//   { id: 'foo' },\n//   React.createElement('a', null, 'bar'),\n//   React.createElement('b'),\n// );\n// 如果想要让 babel 这样的转译器解析到 myReact.createElement 函数中...可以在 JSX 语法前添加一个注释:\n// /** @jsx myReact.createElement */\n// === 测试代码 ===\n\n/** @jsx myReact.createElement */\n\nconst element = myReact.createElement(\"div\", {\n  style: \"background: salmon\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 82,\n    columnNumber: 3\n  }\n}, myReact.createElement(\"h1\", {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 83,\n    columnNumber: 5\n  }\n}, \"Hello World\"), myReact.createElement(\"h2\", {\n  style: \"text-align:right\",\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 84,\n    columnNumber: 5\n  }\n}, \"from myReact\"));\nconst container = document.getElementById('root');\nmyReact.render(element, container);","map":{"version":3,"names":["createElement","type","props","children","map","child","createTextElement","text","nodeValue","render","element","container","dom","document","createTextNode","isProperty","key","Object","keys","filter","forEach","name","appendChild","myReact","getElementById"],"sources":["C:/Code/minireact/src/index.js"],"sourcesContent":["// const element = (\r\n//   <div id='foo'>\r\n//     <a>bar</a>\r\n//     <b />\r\n//   </div>\r\n// );\r\n\r\n// ↓ 相当于使用 React.createElement ↓\r\n\r\n// const element = React.createElement(\r\n//   'div',\r\n//   { id: 'foo' },\r\n//   React.createElement('a', null, 'bar'),\r\n//   React.createElement('b'),\r\n// );\r\n\r\n// ↓ 将 React.createElement 改写为原生 JS 的 createElement ↓\r\n\r\nfunction createElement(type, props, ...children) {\r\n  // 使用 rest parameter 将 children 转化为数组 -> 这样方便通过 map 方法遍历 children 了\r\n  return {\r\n    type,\r\n    props: {\r\n      ...props,\r\n      children: children.map((child) => {\r\n        return typeof child === 'object' ? child : createTextElement(child);\r\n        // 如果 child 是字符串,则创建文本节点;如果 child 是对象,则直接返回\r\n      }),\r\n    },\r\n  };\r\n}\r\n// 创建处理文字节点的函数 createTextElement()\r\nfunction createTextElement(text) {\r\n  return {\r\n    type: 'TEXT_ELEMENT',\r\n    // 为文字节点特设的类型\r\n    props: {\r\n      nodeValue: text,\r\n      children: [],\r\n      // 注意:React 不会包裹原始值,而是直接将原始值作为节点的属性;也不会在没有子节点时创建空的数组...\r\n    },\r\n  };\r\n}\r\n\r\nfunction render(element, container) {\r\n  const dom =\r\n    element.type == 'TEXT_ELEMENT'\r\n      ? document.createTextNode('')\r\n      : document.createElement(element.type);\r\n  // 进一步考虑:要根据元素类型进行不同的处理,即文本节点和元素节点两种情况。\r\n  const isProperty = (key) => key !== 'children';\r\n  Object.keys(element.props)\r\n    .filter(isProperty)\r\n    .forEach((name) => (dom[name] = element.props[name]));\r\n  // 将元素的属性分配每个节点...\r\n  element.props.children.forEach((child) => {\r\n    render(child, dom);\r\n  });\r\n  // element 的子节点也要通过遍历 render 函数来创建\r\n  container.appendChild(dom);\r\n}\r\n\r\nconst myReact = {\r\n  createElement,\r\n  render,\r\n};\r\n\r\n// const element = myReact.createElement(\r\n//   'div',\r\n//   { id: 'foo' },\r\n//   React.createElement('a', null, 'bar'),\r\n//   React.createElement('b'),\r\n// );\r\n\r\n// 如果想要让 babel 这样的转译器解析到 myReact.createElement 函数中...可以在 JSX 语法前添加一个注释:\r\n// /** @jsx myReact.createElement */\r\n\r\n// === 测试代码 ===\r\n\r\n/** @jsx myReact.createElement */\r\nconst element = (\r\n  <div style='background: salmon'>\r\n    <h1>Hello World</h1>\r\n    <h2 style='text-align:right'>from myReact</h2>\r\n  </div>\r\n);\r\nconst container = document.getElementById('root');\r\nmyReact.render(element, container);\r\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA,SAASA,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAiD;EAAA,kCAAVC,QAAU;IAAVA,QAAU;EAAA;;EAC/C;EACA,OAAO;IACLF,IADK;IAELC,KAAK,EAAE,EACL,GAAGA,KADE;MAELC,QAAQ,EAAEA,QAAQ,CAACC,GAAT,CAAcC,KAAD,IAAW;QAChC,OAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCC,iBAAiB,CAACD,KAAD,CAA5D,CADgC,CAEhC;MACD,CAHS;IAFL;EAFF,CAAP;AAUD,C,CACD;;;AACA,SAASC,iBAAT,CAA2BC,IAA3B,EAAiC;EAC/B,OAAO;IACLN,IAAI,EAAE,cADD;IAEL;IACAC,KAAK,EAAE;MACLM,SAAS,EAAED,IADN;MAELJ,QAAQ,EAAE,EAFL,CAGL;;IAHK;EAHF,CAAP;AASD;;AAED,SAASM,MAAT,CAAgBC,OAAhB,EAAyBC,SAAzB,EAAoC;EAClC,MAAMC,GAAG,GACPF,OAAO,CAACT,IAAR,IAAgB,cAAhB,GACIY,QAAQ,CAACC,cAAT,CAAwB,EAAxB,CADJ,GAEID,QAAQ,CAACb,aAAT,CAAuBU,OAAO,CAACT,IAA/B,CAHN,CADkC,CAKlC;;EACA,MAAMc,UAAU,GAAIC,GAAD,IAASA,GAAG,KAAK,UAApC;;EACAC,MAAM,CAACC,IAAP,CAAYR,OAAO,CAACR,KAApB,EACGiB,MADH,CACUJ,UADV,EAEGK,OAFH,CAEYC,IAAD,IAAWT,GAAG,CAACS,IAAD,CAAH,GAAYX,OAAO,CAACR,KAAR,CAAcmB,IAAd,CAFlC,EAPkC,CAUlC;;EACAX,OAAO,CAACR,KAAR,CAAcC,QAAd,CAAuBiB,OAAvB,CAAgCf,KAAD,IAAW;IACxCI,MAAM,CAACJ,KAAD,EAAQO,GAAR,CAAN;EACD,CAFD,EAXkC,CAclC;;EACAD,SAAS,CAACW,WAAV,CAAsBV,GAAtB;AACD;;AAED,MAAMW,OAAO,GAAG;EACdvB,aADc;EAEdS;AAFc,CAAhB,C,CAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;;AACA,MAAMC,OAAO,GACX;EAAK,KAAK,EAAC,oBAAX;EAAA;EAAA;IAAA;IAAA;IAAA;EAAA;AAAA,GACE;EAAA;EAAA;IAAA;IAAA;IAAA;EAAA;AAAA,iBADF,EAEE;EAAI,KAAK,EAAC,kBAAV;EAAA;EAAA;IAAA;IAAA;IAAA;EAAA;AAAA,kBAFF,CADF;AAMA,MAAMC,SAAS,GAAGE,QAAQ,CAACW,cAAT,CAAwB,MAAxB,CAAlB;AACAD,OAAO,CAACd,MAAR,CAAeC,OAAf,EAAwBC,SAAxB"},"metadata":{},"sourceType":"module"}